#!/usr/bin/python3

import hashlib, os, argparse, sys, math

parser = argparse.ArgumentParser(
        description = "Recursively create and check md5 checksums of directories",
        epilog = 'By default, only directories without any subdirectories ("leaves") will be processed. '
                 'This can be overridden with the -f option. '
                 'All files in a directory (except files called "Checksums.md5") will be hashed '
                 'and either stored in the MD5 file or checked against it, depending on operation mode. '
                 "If no operation mode is given, checking mode will be selected. "
                 " ",
        prog = 'album-md5')
group = parser.add_mutually_exclusive_group()
group.add_argument('-c', '--create', action='store_true', help='create MD5 checksum files')
group.add_argument('-p', '--check-paths', action='store_true', help='only check paths, don\'t compare checksums')
parser.add_argument('-s', '--skip', action='store', default=0, type=int, metavar='n', help='skip given number of dirs (to resume an aborted run)')
parser.add_argument('-n', '--number', action='store', default=-1, type=int, metavar='n', help='only process this many dirs (after the skipped ones)')
parser.add_argument('-q', '--quiet', action='count', default=0, help='less progress output (use twice for complete silence)')
parser.add_argument('-f', '--force', action='store_true', help='force processing of files in dirs with subdirs')
parser.add_argument('locations', metavar='dir', type=str, nargs='*', help='a list of directories to parse (default is current dir)')
args = parser.parse_args()

skip = args.skip
hashedBytes = 0
dircount = 0
# number of failed file checks
fails = 0
files = 0
passes = 0
nomd5 = 0
notfound = 0
overwrite_all = False
skip_all = False
cwd = os.getcwd()
dots = False

def processDir(path):
    global cwd, dircount, skip, fails, files, passes, nomd5, notfound, overwrite_all, skip_all, dots
    byteCount = 0

    content = os.listdir(path)
    dirs = [entry for entry in content if os.path.isdir(path + "/" + entry)]

    if dirs:
        dirs.sort()
        for d in dirs:
            byteCount += processDir(path+"/"+d)
        if not args.force:
            return byteCount

    filelist = [entry for entry in content if os.path.isfile(path + "/" + entry)]
    if skip == 0:
        if args.number == 0:
            return 0

        filelist.sort()
        try:
            checksumIndex = filelist.index("Checksums.md5")
        except ValueError:
            checksumIndex = -1
        if checksumIndex > -1:
            filelist = filelist[:checksumIndex] + filelist[checksumIndex+1:]

        # full output: print number of files and name of directory
        if args.quiet==0:
            print("Processing {0:>2} files in {1}".format(len(filelist),
                    "."+path[len(cwd):] if path.startswith(cwd) else path))
        # reduced output: only print a dot for each directory
        elif args.quiet==1:
            print(".", end="")
            sys.stdout.flush()
            dots = True

        checksumsPath = path + "/Checksums.md5"
        if checksumIndex > -1 and args.create:
            if skip_all:
                return 0
            if not overwrite_all:
                # put a newline behind the dots
                if dots:
                    print()
                    dots = False
                while True:
                    answer = input(">>> Checksums.md5 exists. (o)verwrite, o(v)erwrite all, (s)kip, skip al(l), (a)bort? ")
                    if answer.lower() in "ovsla":
                        break
                if answer == "v":
                    overwrite_all = True
                elif answer == "a":
                    exit(1)
                elif answer == "l":
                    skip_all = True
                    return 0
                elif answer == "s":
                    return 0

        checksums = {}
        oldsums = {}
        if not args.create:
            if checksumIndex > -1:
                for line in open(checksumsPath):
                    oldsums[line[34:-1]] = line[:32]
            elif filelist:
                nomd5 += 1
        
        # only process files if needed
        if args.create or checksumIndex > -1:
            for f in filelist:
                files += 1
                oldsum = oldsums.get(f)
                if not (args.create or oldsum):
                    if dots:
                        print()
                        dots = False
                    print(">>> '{0}' not in existing MD5 file." \
                            .format(f if args.quiet == 0 else path + "/" + f), file=sys.stderr)
                    notfound += 1
                elif not args.check_paths:
                    checksums[f] = hashlib.md5(open(path + "/" + f, "rb").read()).hexdigest()
                    byteCount += os.path.getsize(path + "/" + f)
                    if not args.create:
                        if oldsum != checksums[f]:
                            if dots:
                                print()
                                dots = False
                            print(">>> '{0}': checksum error.".format(f), file=sys.stderr)
                            fails += 1
                        else:
                            passes += 1

        if args.create:
            if filelist:
                checksumFile = open(checksumsPath, "wt")
                for f in filelist:
                    print("{0} *{1}".format(checksums[f], f), file=checksumFile)
                checksumFile.close()

        if args.number>-1:
            args.number -= 1

    else:
        skip -= 1

    if filelist:
        dircount += 1
    return byteCount

def plural(number, singular, plural = ""):
    if singular[-1]=="y" and not plural:
        plural = singular[0:-1]+"ies"

    if plural:
        return singular if number==1 else plural
    else:
        return singular+"s" if number!=1 else ""

if not args.locations:
    args.locations.append(os.getcwd())

try:
    for dir in args.locations:
        dir = os.path.abspath(dir)
        hashedBytes += processDir(dir)
except KeyboardInterrupt:
    if dots:
        print()
        dots = False
    if args.create:
        print("\nHashing aborted.")
    else:
        print("\nCheck aborted.")

if dots:
    print()
    dots = False

labels=[]
values=[]

labels.append(plural(dircount, "directory") + " processed")
values.append(dircount)

if args.skip > 0:
    labels.append("  of which skipped at the beginning")
    values.append(args.skip)

if nomd5 > 0:
    labels.append(plural(nomd5, "  directory") + " without checksum file")
    values.append(nomd5)

labels.append(plural(files, "file") + " processed")
values.append(files)

if not args.create:
    if not args.check_paths:
        labels.append(plural(passes, "  check passed", "  checks passed"))
        values.append(passes)

        if fails > 0:
            labels.append(plural(passes, "  check failed", "  checks failed"))
            values.append(fails)

    if notfound > 0:
        labels.append(plural(notfound, "file") + " not listen in checksum file")
        values.append(notfound)

if not args.check_paths:
    labels.append(plural(hashedBytes, "  hashed total filesize"))
    values.append(hashedBytes)

labelwidth = max(len(label) for label in labels)
valuewidth = math.floor(max(0 if value==0 else math.log10(value) for value in values))+1
# that definitely is easier to accomplish
formatstring = """{0:"""+str(labelwidth)+"""}: {1:>"""+str(valuewidth)+"""}"""

if args.quiet != 2 or notfound > 0:
    print("-" * (labelwidth + valuewidth + 2))

for label, value in zip(labels, values):
    print(formatstring.format(label, value))

""" TODO:
- improve ctrl+c behaviour
"""
