#!/usr/bin/python3

import hashlib, os, argparse, sys, math

parser = argparse.ArgumentParser(
        description = "Recursively create and check md5 checksums of directories",
        epilog = 'By default, only directories without any subdirectories ("leaves") will be processed. '
                 'This can be overridden with the -f option. '
                 'All files in a directory (except files called "Checksums.md5") will be hashed '
                 'and either stored in the MD5 file or checked against it, depending on operation mode. '
                 "If no operation mode is given, checking mode will be selected. "
                 " ",
        prog = 'album-md5')
group = parser.add_mutually_exclusive_group()
group.add_argument('-c', '--create', action='store_true', help='create MD5 checksum files')
group.add_argument('-p', '--paths', action='store_true', help='only check paths, don\'t compare checksums (faster)')
parser.add_argument('-s', '--skip', action='store', default=0, type=int, metavar='n', help='skip given number of dirs (to resume an aborted run)')
parser.add_argument('-n', '--number', action='store', default=-1, type=int, metavar='n', help='only process this many dirs (after the skipped ones)')
parser.add_argument('-q', '--quiet', action='count', default=0, help='less progress output (use twice for complete silence)')
parser.add_argument('-f', '--force', action='store_true', help='force processing of files in dirs with subdirs')
parser.add_argument('locations', metavar='dir', type=str, nargs='*', help='a list of directories to parse (default is current dir)')
args = parser.parse_args()

# counting variables for the main recursion
# -----------------------------------------
# number of matching directories (i.e. those that contain files to process)
dircount = 0
# number of matching directories to skip at the beginning
skip = args.skip
# number of files processed
files = 0
# summed size of all hashed files
hashedBytes = 0
# number of failed md5 checks
fails = 0
# number of passed md5 checks
passes = 0
# number of files listed in md5, but physically missing
filesmissing = 0
# number of files not listed in existing md5 file
notinmd5 = 0
# number of matching directories without md5 file
md5missing = 0

# answer flags for the question about already existing md5 files
# overwrite all following md5 collisions
overwrite_all = False
# skip all following directories with md5 collisions
skip_all = False

# whether the last thing printed was a progress dot (i.e. without line break)
dots = False

cwd = os.getcwd()

# main recursive function
def processDir(path):
    global cwd, dircount, skip, fails, files, filesmissing, passes, md5missing, notinmd5, overwrite_all, skip_all, dots
    byteCount = 0

    # recursive part: go through all subdirs
    content = os.listdir(path)
    dirs = [entry for entry in content if os.path.isdir(path + "/" + entry)]
    if dirs:
        dirs.sort()
        for d in dirs:
            byteCount += processDir(path+"/"+d)
        if not args.force:
            return byteCount

    # leaf part: process files
    filelist = [entry for entry in content if os.path.isfile(path + "/" + entry)]

    # only process if this dir is not part of the first x to skip
    if skip > 0:
        skip -= 1
    else:
        # abort processing here if given dir limit is reached
        if args.number == 0:
            return 0

        filelist.sort()
        # see if checksum file exists
        md5exists = "Checksums.md5" in filelist
        if md5exists:
            # and remove it from the list of files to process
            filelist.remove("Checksums.md5")

        # full output mode: print number of files and name of directory
        if args.quiet==0:
            if md5exists or args.create:
                print("Processing {0:>2} files in {1}".format(len(filelist),
                        "."+path[len(cwd):] if path.startswith(cwd) else path))
            else:
                print("No checksum file in", "."+path[len(cwd):] if path.startswith(cwd) else path)

        # reduced output: only print a dot for each directory
        elif args.quiet==1:
            print(".", end="")
            sys.stdout.flush()
            dots = True

        # the checksum file will be overwritten -> ask how to proceed
        if md5exists and args.create:
            if skip_all:
                return 0
            if not overwrite_all:
                # put a newline behind the dots
                if dots:
                    print()
                    dots = False
                while True:
                    answer = input(">>> Checksums.md5 exists: (O)verwrite, o(v)erwrite all, (s)kip, skip al(l), (a)bort? ")
                    if answer.lower() in "ovsla":
                        break
                if answer == "v":
                    overwrite_all = True
                elif answer == "a":
                    exit(1)
                elif answer == "l":
                    skip_all = True
                    return 0
                elif answer == "s":
                    return 0

        checksumsPath = path + "/Checksums.md5"
        checksums = {}
        oldsums = {}
        # read entries in MD5 file
        if not args.create:
            if md5exists:
                for line in open(checksumsPath):
                    oldsums[line[34:-1]] = line[:32]
                for file in oldsums:
                    if not file in filelist:
                        if dots:
                            print()
                            dots = False
                        print(">>> '{0}' from MD5 file does not exist." \
                                .format(file if args.quiet == 0 else path + "/" + file), file=sys.stderr)
                        filesmissing += 1
            elif filelist:
                md5missing += 1
        
        # only process files if needed (i.e. being hashed or checked against existing MD5)
        if args.create or md5exists:
            for f in filelist:
                files += 1

                oldsum = oldsums.get(f)
                # want to check, but file does not exist in MD5
                if not args.create and not oldsum:
                    if dots:
                        print()
                        dots = False
                    print(">>> '{0}' not in existing MD5 file." \
                            .format(f if args.quiet == 0 else path + "/" + f), file=sys.stderr)
                    notinmd5 += 1
                    # that file doesn't count as it doesn't have to be processed
                    files -= 1
                # want to create or check the md5
                elif not args.paths:
                    checksums[f] = hashlib.md5(open(path + "/" + f, "rb").read()).hexdigest()
                    byteCount += os.path.getsize(path + "/" + f)
                    if not args.create:
                        if oldsum != checksums[f]:
                            if dots:
                                print()
                                dots = False
                            print(">>> '{0}': checksum error.".format(f), file=sys.stderr)
                            fails += 1
                        else:
                            passes += 1

        # write ne checksum file
        if args.create:
            if filelist:
                checksumFile = open(checksumsPath, "wt")
                for f in filelist:
                    print("{0} *{1}".format(checksums[f], f), file=checksumFile)
                checksumFile.close()

        # decrease counter for fixed number of dirs to process
        if args.number>-1:
            args.number -= 1

    # count directory as processed if it contains processed files
    if filelist:
        dircount += 1
    return byteCount

# print plural forms of words depending on assiociated number
def plural(number, singular, plural = ""):
    if singular[-1]=="y" and not plural:
        plural = singular[0:-1]+"ies"

    if number == 1:
        return singular
    elif plural:
        return plural
    else:
        return singular+"s"

# use current dir if no dir to process was given
if not args.locations:
    args.locations.append(os.getcwd())

# recurse every passed directory
try:
    for dir in args.locations:
        dir = os.path.abspath(dir)
        hashedBytes += processDir(dir)
except KeyboardInterrupt:
    if dots:
        print()
        dots = False
    if args.create:
        print("\nHashing aborted.")
    else:
        print("\nCheck aborted.")

if dots:
    print()
    dots = False

# output stuff, left and right column
labels=[]
values=[]

labels.append(plural(dircount, "directory") + " processed")
values.append(dircount)

if args.skip > 0:
    labels.append("  of which skipped at the beginning")
    values.append(args.skip)

if md5missing > 0:
    labels.append(plural(md5missing, "  directory") + " without checksum file")
    values.append(md5missing)

labels.append(plural(files, "file") + " processed")
values.append(files)

if not args.create:
    if not args.paths:
        labels.append(plural(passes, "  check passed", "  checks passed"))
        values.append(passes)

        if fails > 0:
            labels.append(plural(passes, "  check failed", "  checks failed"))
            values.append(fails)

if not args.paths:
    labels.append("  hashed bytes")
    values.append(hashedBytes)

if not args.create:
    if notinmd5 > 0:
        labels.append(plural(notinmd5, "file") + " not listen in checksum file")
        values.append(notinmd5)

    if filesmissing > 0:
        labels.append(plural(filesmissing, "file") + " missing")
        values.append(filesmissing)

# get maximum width of items for both columns
labelwidth = max(len(label) for label in labels)
valuewidth = math.floor(max(0 if value==0 else math.log10(value) for value in values))+1
# that definitely is easier to accomplish
formatstring = """{0:"""+str(labelwidth)+"""}: {1:>"""+str(valuewidth)+"""}"""

# separation line between process output and result table
if args.quiet != 2 or notinmd5 > 0:
    print("-" * (labelwidth + valuewidth + 2))

# print results
for label, value in zip(labels, values):
    print(formatstring.format(label, value))

""" TODO:
- improve ctrl+c behaviour
"""
