#!/usr/bin/python3

import argparse
import hashlib
import math
import os
import sys
import time

parser = argparse.ArgumentParser(
    description="Recursively create and verify md5 checksums in directories",
    epilog='By default, only directories without any subdirectories ("leaves") will be processed. '
           'This can be overridden with the -f option. '
           'All files in a directory (except the checksum filename) will be hashed '
           'and either stored in the MD5 file or checked against it, depending on operation mode. '
           "If no operation mode is given, checking mode will be selected.",
    prog='album-md5')
group = parser.add_mutually_exclusive_group()
group.add_argument('-c', '--create', action='store_true', help='create checksums and write them to files')
group.add_argument('-F', '--filename', action='store', default='Checksums.md5', metavar='name', help='name of checksum files (default: Checksums.md5)')
group.add_argument('-p', '--paths', action='store_true', help='only check paths, don\'t compare checksums (faster)')
parser.add_argument('-s', '--skip', action='store', default=0, type=int, metavar='n', help='skip given number of dirs (to resume an aborted run)')
parser.add_argument('-n', '--number', action='store', default=-1, type=int, metavar='n', help='only process this many dirs (after the skipped ones)')
parser.add_argument('-q', '--quiet', action='count', default=0, help='less progress output (-q: print dots instead of paths, -qq: print no progress at all, -qqq: suppress warnings about missing checksum files)')
parser.add_argument('-f', '--force', action='store_true', help='force processing of files in dirs with subdirs')
parser.add_argument('-o', '--overwrite', action='store_true', help='override checksum files without asking')
parser.add_argument('locations', metavar='dir', type=str, nargs='*', help='a list of directories to parse (default is current dir)')
args = parser.parse_args()

# clean-up of input
args.filename = os.path.basename(args.filename)
if args.quiet > 3:
    args.quiet = 3


# counting variables for the main recursion
# -----------------------------------------
# number of matching directories (i.e. those that contain files to process)
dircount = 0
# number of matching directories to skip at the beginning
skip = args.skip
# number of matching directories after which to exit
limit = args.number
# number of directories skipped due to answer to overwrite question
skipped_overwrites = 0
# number of files processed
files = 0
# number of failed md5 checks
fails = 0
# number of passed md5 checks
passes = 0
# number of files listed in md5, but physically missing
files_missing = 0
# number of files not listed in existing md5 file
not_in_md5 = 0
# number of matching directories without md5 file
md5_missing = 0

# answer flags for the question about already existing md5 files
# overwrite all following md5 collisions
overwrite_all = args.overwrite
# skip all following directories with md5 collisions
skip_all = False
# whether a question was asked (which means there was output)
question_asked = False

# whether the last thing printed was a progress dot (i.e. without line break)
dots = False

cwd = os.getcwd()


class RecursionException(Exception):
    pass


# main recursive function
def recurseDir(path):
    if not os.path.isdir(path):
        return 0

    global cwd, dircount, fails, files, files_missing, limit, md5_missing, not_in_md5, passes, skip, skipped_overwrites, overwrite_all, skip_all, question_asked, dots
    hashed_bytes = 0

    # recursive part: go through all subdirs
    content = os.listdir(path)
    dirs = [entry for entry in content if os.path.isdir(path + os.path.sep + entry)]
    if dirs:
        dirs.sort()
        for d in dirs:
            hashed_bytes += recurseDir(path + os.path.sep + d)
        if not args.force:
            return hashed_bytes

    # leaf part: process files
    filelist = [entry for entry in content if os.path.isfile(path + os.path.sep + entry)]

    # only process if this dir is not part of the first x to skip
    if skip > 0:
        skip -= 1
    else:
        # abort processing here if given dir limit is reached
        if limit == 0:
            return 0

        filelist.sort()
        # see if checksum file exists
        md5exists = args.filename in filelist
        if md5exists:
            # and remove it from the list of files to process
            filelist.remove(args.filename)

        # full output mode: print number of files and name of directory
        if args.quiet == 0:
            if md5exists or args.create:
                if skip_all:
                    print("Skipping ", end="")
                else:
                    print("Processing {0:>2} files in ".format(
                        len(filelist)), end="")
                print("."+path[len(cwd):] if path.startswith(cwd) else path)
        if not md5exists and not args.create and args.quiet < 3:
            print("No checksum file in", "."+path[len(cwd):]
                  if path.startswith(cwd) else path)

        # reduced output: only print a dot for each directory
        elif args.quiet == 1:
            print(".", end="")
            sys.stdout.flush()
            dots = True

        # the checksum file will be overwritten -> ask how to proceed
        if md5exists and args.create:
            if skip_all:
                dircount += 1
                skipped_overwrites += 1
                return 0
            if not overwrite_all:
                # put a newline behind the dots
                if dots:
                    print()
                    dots = False
                while True:
                    question_asked = True
                    answer = input(">>> Checksum file exists: (O)verwrite, o(v)erwrite all, (s)kip, skip al(l), (a)bort? ")
                    if answer.lower() in "ovsla":
                        break
                if answer == "v":
                    overwrite_all = True
                elif answer == "a":
                    raise RecursionException("aborted")
                elif answer == "l":
                    skip_all = True
                    dircount += 1
                    skipped_overwrites += 1
                    return 0
                elif answer == "s":
                    skipped_overwrites += 1
                    return 0

        checksums_path = path + os.path.sep + args.filename
        checksums = {}
        oldsums = {}
        # read entries in MD5 file
        if not args.create:
            if md5exists:
                for line in open(checksums_path):
                    file, md5 = line[34:-1], line[:32]
                    oldsums[file] = md5
                    if not file in filelist:
                        if dots:
                            print()
                            dots = False
                        print(">>> '{0}' from MD5 file does not exist.".format(
                            file if args.quiet == 0 else path + os.path.sep + file),
                            file=sys.stderr)
                        files_missing += 1
            elif filelist:
                md5_missing += 1

        # only process files if needed (i.e. being hashed or checked against existing MD5)
        if args.create or md5exists:
            for f in filelist:
                files += 1

                oldsum = oldsums.get(f)
                # want to check, but file does not exist in MD5
                if not args.create and not oldsum:
                    if dots:
                        print()
                        dots = False
                    print(">>> '{0}' not in existing MD5 file.".format(
                        f if args.quiet == 0 else path + os.path.sep + f),
                        file=sys.stderr)
                    not_in_md5 += 1
                    # that file doesn't count as it doesn't have to be processed
                    files -= 1
                # want to create or check the md5
                elif not args.paths:
                    checksums[f] = hashlib.md5(open(path + os.path.sep + f, "rb").read()).hexdigest()
                    hashed_bytes += os.path.getsize(path + os.path.sep + f)
                    if not args.create:
                        if oldsum != checksums[f]:
                            if dots:
                                print()
                                dots = False
                            print(">>> '{0}': checksum error.".format(f), file=sys.stderr)
                            fails += 1
                        else:
                            passes += 1

        # write ne checksum file
        if args.create:
            if filelist:
                with open(checksums_path, "wt") as md5_file:
                    for f in filelist:
                        print("{0} *{1}".format(checksums[f], f),
                              file=md5_file)

        # decrease counter for fixed number of dirs to process
        if limit > -1:
            limit -= 1

    # count directory as processed if it contains processed files
    if filelist:
        dircount += 1
    return hashed_bytes


# print plural forms of words depending on assiociated number
def plural(number, singular, plural=""):
    if singular[-1] == "y" and not plural:
        plural = singular[0:-1]+"ies"

    if number == 1:
        return singular
    elif plural:
        return plural
    else:
        return singular+"s"

# use current dir if no dir to process was given
if not args.locations:
    args.locations.append(os.getcwd())

hashed_bytes = 0

# recurse every passed directory
try:
    starttime = time.time()
    for dir in args.locations:
        dir = os.path.abspath(dir)
        hashed_bytes += recurseDir(dir)
except KeyboardInterrupt:
    if dots:
        print()
        dots = False
    if args.create:
        print("\nHashing aborted.")
    else:
        print("\nCheck aborted.")
except RecursionException:
    pass
finally:
    endtime = time.time()
    duration = endtime - starttime

if dots:
    print()
    dots = False

# output stuff, left and right column
labels, values = [], []

labels.append(plural(dircount, "directory") + " processed")
values.append(dircount)

if args.skip > 0:
    labels.append("  of which skipped at the beginning")
    values.append(args.skip)

if skipped_overwrites > 0:
    labels.append("  of which skipped due to overwriting")
    values.append(skipped_overwrites)

if md5_missing > 0:
    labels.append(plural(md5_missing, "  directory") + " without checksum file")
    values.append(md5_missing)

labels.append(plural(files, "file") + " processed")
values.append(files)

if not args.create:
    if not args.paths:
        labels.append(plural(passes, "  check passed", "  checks passed"))
        values.append(passes)

        if fails > 0:
            labels.append(plural(passes, "  check failed", "  checks failed"))
            values.append(fails)

if not args.paths:
    labels.append("  hashed bytes")
    values.append(hashed_bytes)

    # --paths is fast, we don’t need time stats (also, hashed_bytes == 0)
    labels.append("time elapsed")
    values.append("{0:3.1f} seconds ({1:0.1f} MiB/second)".format(
        duration, hashed_bytes/1048576/duration if duration != 0 else 0))

if not args.create:
    if not_in_md5 > 0:
        labels.append(plural(not_in_md5, "file") + " not listen in checksum file")
        values.append(not_in_md5)

    if files_missing > 0:
        labels.append(plural(files_missing, "file") + " missing")
        values.append(files_missing)

# get maximum width of items for both columns
labelwidth = max(len(label) for label in labels)
valuewidth = math.floor(max(
    0 if value == 0 or isinstance(value, str) else
    math.log10(value) for value in values))+1
# that definitely is easier to accomplish
formatstring = """{0:"""+str(labelwidth)+"""}: {1:>"""+str(valuewidth)+"""}"""

# separation line between process output and result table
if args.quiet < 3 and (not_in_md5 or files_missing or md5_missing or files or dircount) or question_asked:
    print("-" * (labelwidth + valuewidth + 2))

# print results
for label, value in zip(labels, values):
    print(formatstring.format(label, value))

if fails or files_missing or not_in_md5 or md5_missing:
    exit(1)
