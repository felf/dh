#!/usr/bin/python3

import hashlib, os, argparse, sys, math

parser = argparse.ArgumentParser(
        description = "Recursively create and check md5 checksums of directories",
        prog = 'album-md5')
parser.add_argument('-c', '--check', action='store_true', help='check existing md5 files')
parser.add_argument('-p', '--check-paths', action='store_true', help='only check paths in md5 files, not the checksums')
parser.add_argument('-s', '--skip', action='store', default=0, type=int, metavar='n', help='skip given number of dirs (to resume an aborted run)')
parser.add_argument('-q', '--quiet', action='count', default=0, help='less output (use twice for complete silence)')
parser.add_argument('locations', metavar='dir', type=str, nargs='*', help='a list of directories to parse (default is current dir)')
args = parser.parse_args()

# imply --check if only --check-paths was used
if args.check_paths and not args.check:
    args.check = True

skip = args.skip
hashedBytes = 0
dircount = 0
# number of failed file checks
fails = 0
files = 0
passes = 0
nomd5 = 0
notfound = 0
overwrite_all = False
skip_all = False
cwd = os.getcwd()
dots = False

def processDir(path):
    global cwd, dircount, skip, fails, files, passes, nomd5, notfound, overwrite_all, skip_all, dots
    byteCount = 0

    content = os.listdir(path)
    dirs = [entry for entry in content if os.path.isdir(path + "/" + entry)]

    if dirs:
        dirs.sort()
        for d in dirs:
            byteCount += processDir(path+"/"+d)
        return byteCount

    filelist = [entry for entry in content if os.path.isfile(path + "/" + entry)]
    if skip == 0:
        filelist.sort()
        try:
            checksumIndex = filelist.index("Checksums.md5")
        except ValueError:
            checksumIndex = -1
        if checksumIndex > -1:
            filelist = filelist[:checksumIndex] + filelist[checksumIndex+1:]

        # full output: print number of files and name of directory
        if args.quiet==0:
            print("Processing {0:>2} files in {1}".format(len(filelist),
                    "."+path[len(cwd):] if path.startswith(cwd) else path))
        # reduced output: only print a dot for each directory
        elif args.quiet==1:
            print(".", end="")
            dots = True

        checksumsPath = path + "/Checksums.md5"
        if checksumIndex > -1 and not args.check:
            if skip_all:
                return 0
            if not overwrite_all:
                # put a newline behind the dots
                if dots:
                    print()
                    dots = False
                while True:
                    answer = input(">>> Checksums.md5 exists. (o)verwrite, o(v)erwrite all, (s)kip, skip al(l), (a)bort? ")
                    if answer.lower() in "ovsla":
                        break
                if answer == "v":
                    overwrite_all = True
                elif answer == "a":
                    exit(1)
                elif answer == "l":
                    skip_all = True
                    return 0
                elif answer == "s":
                    return 0

        checksums = {}
        oldsums = {}
        if args.check:
            if checksumIndex > -1:
                for line in open(checksumsPath):
                    oldsums[line[34:-1]] = line[:32]
            else:
                nomd5 += 1
        
        # only process files if needed
        if not args.check or checksumIndex > -1:
            for f in filelist:
                files += 1
                oldsum = oldsums.get(f)
                if args.check and not oldsum:
                    if dots:
                        print()
                        dots = False
                    print(">>> '{0}' not in existing MD5 file.".format(f), file=sys.stderr)
                    notfound += 1
                elif not args.check_paths:
                    checksums[f] = hashlib.md5(open(path + "/" + f, "rb").read()).hexdigest()
                    byteCount += os.path.getsize(path + "/" + f)
                    if args.check:
                        if oldsum != checksums[f]:
                            if dots:
                                print()
                                dots = False
                            print(">>> '{0}': checksum error.".format(f), file=sys.stderr)
                            fails += 1
                        else:
                            passes += 1

        if not args.check:
            checksumFile = open(checksumsPath, "wt")
            for f in filelist:
                print("{0} *{1}".format(checksums[f], f), file=checksumFile)
            checksumFile.close()

    else:
        skip -= 1

    if filelist:
        dircount += 1
    return byteCount

def plural(number, singular, plural = ""):
    if singular[-1]=="y" and not plural:
        plural = singular[0:-1]+"ies"

    if plural:
        return singular if number==1 else plural
    else:
        return singular+"s" if number!=1 else ""

if not args.locations:
    args.locations.append(os.getcwd())

for dir in args.locations:
    dir = os.path.abspath(dir)
    hashedBytes += processDir(dir)

if dots:
    print()
    dots = False

labels=[]
values=[]

labels.append(plural(dircount, "directory") + " processed")
values.append(dircount)

if args.skip > 0:
    labels.append(plural(args.skip, "  skipped directory"))
    values.append(args.skip)

if nomd5 > 0:
    labels.append(plural(nomd5, "  directory") + " without checksum file")
    values.append(nomd5)

labels.append(plural(files, "file") + " processed")
values.append(files)

if args.check:
    if not args.check_paths:
        labels.append(plural(passes, "  check passed", "  checks passed"))
        values.append(passes)

        if fails > 0:
            labels.append(plural(passes, "  check failed", "  checks failed"))
            values.append(fails)

    if notfound > 0:
        labels.append(plural(notfound, "file") + " not listen in checksum file")
        values.append(notfound)

if not args.check_paths:
    labels.append(plural(hashedBytes, "  hashed total filesize"))
    values.append(hashedBytes)

labelwidth = max(len(label) for label in labels)
valuewidth = math.floor(max((math.log10(value) for value in values)))+1
# that definitely is easier to accomplish
formatstring = """{0:"""+str(labelwidth)+"""}: {1:>"""+str(valuewidth)+"""}"""

if args.quiet != 2:
    print("-" * (labelwidth + valuewidth + 2))

for label, value in zip(labels, values):
    print(formatstring.format(label, value))

""" TODO:
- improve ctrl+c behaviour
"""
